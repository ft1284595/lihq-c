								Linux_c系统开发学习笔记

I/O: input & output是一切实现的基础
	stdio标准IO
	sysio系统调用IO(文件IO)

stdio: FILE类型贯穿始终

首先补充两个错误处理的函数:
	perror();
	strerror();

	C语言提供了perror()和strerror()函数来显示与errno相关的文本消息.
	perror()函数显示您传给它的字符串,后跟一个冒号,一个空格和当前errno值的文本表示形式.
	strerror()函数,返回一个指针,指针指向当前errno值的文本表示形式.
	两者的区别在于perror()向stderr输出结果，若你的程序将标准错误输出重定向到/dev/null,那就看不到了,就不能用perror了
	而strerror的作用只是将errno对应的错误消息字符串返回.你可以自己决定咋样处理字符串,比如可以存到日志,也可以直接printf出来.

fopen(); 
fopen函数会返回一个FILE类型的指针,那么这个指针指向的结构体FILE是保存在内存中的什么位置(栈,静态区,还是堆)?

栈(✗)				静态区(✗)				堆(✓)
FILE *fopen(const char *restrict pathname, const char *restrict mode)
{
	/*	
	//如果返回的是在栈上,那么代码类似下面的写法
	FILE tmp;
	....

	return tmp;		//这样的实现,在fopen函数结束的时候,tmp也相应的消失了
	*/

	/*
	//静态区的实现
	static FILE tmp;
	...
	...
	
	return tmp;	//这样的实现的确可延长tmp的生命周期至fopen函数结束以后,
	但是有缺点,因为static变量使用的是同一块内存, 如果你调用fopen()两次,那么后面调用的返回值会覆盖第一次的返回值
	*/

	/*
	返回值在堆上的实现
	*/
	FILE *tmp = NULL;

	tmp = malloc(sizeof(FILE));	//有malloc操作就必定会有对应的free来释放内存,free操作在fclose()中
	tmp->xx = xxx;
	....

	return tmp;
}

fopen() 有两个参数,第一个参数是文件名称,第二个参数是打开的模式mode
mode主要有r,r+,		w,w+,	a,a+
这其中只有r和r+要求文件必须存在,如果文件不存在就会返回NULL,
w和a模式,如果文件不存在就创建文件

还有一种模式b,这种模式在linux环境下没有意义,它是在windows下,表示以2进制的方式


fclose();

小技巧: 如果一个函数返回一个指针,并且关于这个指针还有相关的互逆操作(比如:fopen, fclose),那么这个指针指向的内容是在堆上.
如果没有互逆操作的函数(由于种种原因造成的),那么这个指针指向的内容是在堆上还是在静态区是不能确定的,需要你自己写测试代码来判断.

fgetc();
fputc();

fgets();
	char *fgets(char *buf, size, FILE *stream);
	知识点:对于任何一个非空的文件,文件中的最后都一定会有一个字符'\n'(可以使用cat -A filename 查看文件中的所有字符)
	fgets函数的正常结束有两种情况:
		(1)函数读到了size-1个字节, 第size个字节是专门预留给'\0'的
		(2)函数遇到了'\n'
		但是还有一种边界情况, 考虑下面的情况
			#define SIZE 	5	
			char buf[SIZE]
			char *fgets(buf, SIZE, FILE *stream);

			现在有一个文件test的内容是:
			abcd
			请问fgets函数需要读取多少次才能读完文件test的全部内容.
			答案:是2次.
			根据上面的常识我们知道文件的内容其实是abcd\n	
			宏定义buf的SIZE是5, 所以一次最多只能读取SIZE-1(4)个字节

			第1次:abcd'\0'
			第2次:'\n''\0'
			


fputs();

fread();
	size_t fread(void *ptr,size_t size, size_t nmemb,FILE *stream);

fwrite();
	size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

fread()和fwrite()会从文件中读取或写入item,单个item的大小是size, nmemb表示要读/写多少个item.
On  success,  fread() and fwrite() return the number of items read or written.  This number equals the number of bytes transferred only
       when size is 1.  If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).

fread()和fwrite()在使用上有限制,它们只能在item的大小是固定长度的情况下才能正常调用,如果单个item的大小不固定,那么就会出错.
fread和fwrite在他们不能读取或写入一个完整的item的时候,他们的返回值为0.
考虑下面的情况:
fread(buf, size, nmemb, fp)
我们从文件中读取数据, 同样是读数据我们可以fread(buf, 1, 10, fp)也可以fread(buf, 10, 1, fp);
同样是调用fread,有什么区别. 
分为有两种情况
1-->数据量充足
2-->只有5个字节


fread(buf, 1, 10, fp);	//读取10个item,每个item的大小是1个字节
1--> 返回值是10-->10字节
2-->读取5个item,每个item的大小是1个字节, 返回值是5-->5字节

fread(buf, 10, 1, fp);//读取1个item, item大小为10字节
1--> 返回值是10 --> 10字节
2-->读取不了1个10字节的item,文件中只有5字节不够,一个item,返回值是0 -->  ??? 你就不能根据返回值来判断文件中还剩多少字节

所以推荐使用单字节读取的方式,fread(buf, 1, 10, fp);

printf();
scanf();

fseek(); //设置文件位置指针到指定的位置
	int fseek(FILE *stream, long offset, int whence);
ftell();//The ftell() function obtains the current value of the file position indicator for the stream pointed to by stream.
    long ftell(FILE *stream);
rewind();
    void rewind(FILE *stream);

	rewind函数相当于 fseek(stream, 0L, SEEK_SET)

fseek函数和ftell函数由于历史原因,在使用起来有缺陷. fseek函数中的参数offset是long类型,ftell的返回值是long类型.
以ftell函数来说,这个函数返回的是当前文件指针所在的位置.这个返回值一般都是一个正整数,除非ftell函数运行出错,才返回-1.
而通常状况下long类型的取值范围: -2^31 ~ 2^31-1 也就是 -2G ~ 2G-1. 也就是说如果一个文件的大小超过2G,ftell函数就不能正常返回文件指针的位置了.
同理, fseek函数中的offset的最大值也就是2G-1 ,这个数值在以前硬件还没有蓬勃发展起来的时候,还是足够用的,但是现在就不一定了.
为了解决这个问题所以后来就有了fseeko和ftello函数

int fseeko(FILE *stream, off_t offset, int whence);
off_t ftello(FILE *stream);

使用off_t来代替long类型, off_t具体占几个字节可以使用宏定义来指定(man page里面有写怎么指定).

但是通过查看man page知道这两个函数
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SUSv2.
	   
也就是说fseeko, ftello不是C标准的函数.所以使用起来有限制.不能完全使用fseeko替代fseek
那么如果文件大小超过2G,就得用其他方法来定位文件位置指针





fflush();
缓冲区的作用: 大多数情况下是好事, 合并系统调用

行缓冲: 
	换行时候刷新,
	满了的时候刷新,
	强制刷新(标准输出就是这样的,因为标准输出是终端设备)

全缓冲:
	满了的时候刷新,
	强制刷新(默认,只要不是终端设备的其他设备)

无缓冲:
	如stderr, 需要立即输出的内容

	setvbuf函数可以设置缓冲区的模式, 具体查看man手册
		_IONBF: unbuffered
		_IOLBF: line buffered
		_IOFBF: fully buffered

	通常情况下我们不会使用到setvbuf函数