								一、基本概念
1. 以helloworld为例对写程序的思路提出如下要求：
	1) 头文件正确包含的重要性
	2）以函数为单位来进行程序编写
	3) 声明部分+实现部分
	4) return 0;
	5) 多用空格空行
	6) 添加注释
2. 算法: 解决问题的方法.(流程图,NS图,有限状态机FSM)
3. 程序: 用某种语言实现算法
4. 进程:
5. 防止写越界,防止内存泄露,谁打开谁关闭,谁申请谁释放

								二、数据类型,运算符和表达式
1.数据类型:(基本数据类型,参考图片: C语言数据类型)
	参考图片: 基本数据类型
	1) 所占字节数
	2) 存储区别
	3) 不同类型的数据间进行转换(隐式,显式->强制类型转换)
	4) 特殊性:
		(1) 布尔型bool, 标准C里面没有这个类型, 后来新的C标准中才加入了这个类型, 使用bool类型需要引入stdbool.h头文件
		(2) float类型
		(3) char型是否有符号(不能确定,因为它是未定义行为)
		(4) 不同形式的0值: 0, '0', "0", '\0'
		(5) 数据类型与后续代码中所使用的输入输出要匹配(防止自相矛盾)

2. 常量与变量
常量: 在程序执行过程中值不会发生变化的量
分类: 整型常量,实型常量,字符常量,字符串常量,标识常量
	整型常量: 1,790,76,52
	实型常量: 3.14, 5.26, 1.9999
	字符常量: 由单引号引起来的单个字符或转义字符, 如'a', 'X', '\n', '\t'
				'\ddd' 表示一个3位的8进制数, 如 '\015'
				'\xhh' 表示一个2位的16进制数, 如 '\x7f', 表示16进制的7f

				陷阱1: \018 这个写法对吗?
				如果这是一个\ddd表示的8进制数,那么不可能出现8, 所以这个\018不是一个字符常量,它有可能是一个字符串,\0,1和8
	字符串常量: 由双引号引起来的一个或多个字符组成的序列,(空串)
				如: "", "a", "abXYZ", "abc\n\021\018"
	
	标识常量: #define, 处理是在程序的预处理阶段, 占编译时间(也就是不消耗运行时间),一改全改.它的缺点是: 不检查语法,只是单纯的宏体与宏名之间的替换


变量: 用来保存一些特定内容,并且在程序执行过程中随时会发生变化的量
定义: 	[存储类型] 数据类型 标识符 = 值
				TYPE NAME = VALUE;
		标识符: 由字母,数字,下划线组成且不能以数字开头的一个标识序列. 编写标识符尽量做到见名知意
		数据类型: 基本数据类型 + 构造类型
		值: 注意类型匹配

		存储类型: auto(定义型), static(定义型), register, extern(说明型)
			auto: 默认, 自动分配空间, 自动回收空间.
			register: (建议型)寄存器类型, 只能用来局部变量,不能定义全局变量;
				大小有限制,只能定义32位大小的数据类型(32位系统), 比如double就不可以定义为register.
				寄存器没有地址,所以一个寄存器类型的变量无法打印出地址查看或使用.
			static: 静态型,自动初始化为0值或空值,并且这种类型变量的值有继承性.另外,常用于修饰变量或函数.被static修饰的变量和函数被限制在当前源文件(xxx.c)中使用,
			防止被其他.c文件使用.  static的作用类似于防止被修饰的函数或变量被扩散使用
			extern: 说明型,意味着不能改变被说明的变量的值或类型

	变量的生命周期和作用范围:
		(1) 全局变量和局部变量
		(2) 局部变量和局部变量
		(3) 参考图片:存储类型比较.png

3. 运算符和表达式

表达式和语句的区别: 
	表达式是由变量和运算符组成的, 
	在表达式的后面加一个分号(;),就是语句.

表达式					语句
i=1						i=1;
i=j*2					i=j*2; 	

运算符部分:
	(1) 每个运算符所需要的参与运算的操作个数
	(2) 结合性
	(3) 优先级
	(4) 运算符的特殊用法
		比如: % 要求两边的操作数都是整型
			 逻辑运算符(&&,||)的短路特性
			 逗号运算符(,) 逗号运算符表达式的值是这个逗号表达式中最后一项的值
			 sizeof不是关键字而是一个运算符,它用来求字节数
	(5) 位运算的重要意义
		将操作数中第n位置1,其他位不变:  num = num | 1 << n; 
		将操作数中第n位清0,其他位不变:  num = num & ~(1 << n);
		测试第n位是0还是1: if(num & 1 << n) ...
		从一个指定宽度的数中取出其中的某几位: 

		int a = 11010010
		a << 2
				01001000
		a >> 2  00110100
				10010000
		

	对于自增,自减的操作有一个原则: 如果运算符在前,先进行计算,再取变量值使用.
	如果变量在前, 先取变量值使用,再进行计算.

	int i = 1;
	i++ 	-->	表达式的值为1, i值为2
	++i		--> 表达式的值为2, i值为2

	int i = 1, j = 10, value;
	/*
	value = i++ + ++j;
	计算过程是:
	i;
	j = j + 1;
	value = i + j;
	i = i + 1;
	*/
	value = --i + j++;
	计算过程是:
	i = i - 1;
	j;
	value = i + j;
	j = j + 1;

	value = i++ + ++i - i-- + --i; //这样的语句就不好,搞脑子. 这条语句所有的自增和自减操作的变量都是同一个变量i,有歧义.
	在不同的编译器下,他们的结果并不一样,因为不同的编译器对这条语句的解释是不同的.

								三. 输入,输出专题
input & output -> I/O(标准IO,文件IO)

1. 格式化的输入输出函数: scanf, printf
	int printf(const char *format, ...);
	format: "%[修饰字符]格式字符"
	参照图片:标准输出修饰符与输入输出格式字符

	int scanf(const char *format, ...);
	format: 抑制符*,这个符号表示忽略多少字符, 他可以吃掉一些不想要的字符.
	%s的使用是比较危险的,因为不知道存储空间大小
	scanf放在循环结构中要注意能否接收到正常有效的内容(也就是要通过scanf函数的返回值来判断是否接受到了有效内容)
	scanf("%d",&i);
	scanf("%*c%c", &ch);	//这里的*c会匹配上面一行输入i的时候的回车符,并忽略掉这个字符
	

2. 字符输入输出函数: getchar, putchar
3. 字符串输入输出函数: gets(!), puts
	gets:十分危险的函数, 可以用fgets,getline来替代.(fgets治标不治本,getline比较好)

输入,输出 练习题
1.一个水分子的质量大约为3.0e-23克, 一夸脱水大约有950克,编写一个程序,要求从终端输入水的夸脱数,然后显示这么多夸脱水中大概有多少个水分子.
2.从终端输入三角形的三边长,求面积
	s = 1/2*(a+b+c);
	area = sqrt(s*(s-a)*(s-b)*(s-c));
3.从终端输入a,b,c的值,求方程的根.
例: ax^2 +bx + c = 0 设b*b -4ac >= 0
	x1 = (-b+sqrt(b*b-4ac))/2a
	x2 = (-b-sqrt(b*b-4ac))/2a

								流程控制
顺序,选择,循环
NS图,流程图  工具Dia
简单结构与复杂结构: 自然流程

顺序: 语句逐句执行
选择: 出现了一种以上的情况
循环: 在某个条件成立的情况下,重复执行某个动作

关键字:
选择: if-else switch-case
循环: while, do-while, for, if-goto
辅助控制: continue, break


详解: if-else:
格式: 
		if(exp)
			cmd;
	或:		
		if(exp)
			cmd1;
		else
			cmd2;
注意: else只与离它最近的if相匹配,所以最好使用大括号{}来明确指定if-else的匹配关系
	int a = 1, b = 1, c = 2;
	if(a==b)
		if(b==c)
			printf("a == b == c\n");
	else
		printf("a != b\n");

	//这段程序的输出是a != b

	int a = 1, b = 1, c = 2;
	if(a==b){
		if(b==c)
			printf("a == b == c\n");
	}
	else{
		printf("a != b\n");
	}

	//这段程序的结果是没有任何语句会被打印出来

详解switch-case
语法格式:
	switch(exp)
	{
		case 常量表达式:
			break;
		case 常量表达式:
			break;
		...

		default:
	}

详解循环: while do-while for if-goto
语法格式:
	while:(最少的执行次数为0次)
		while(exp)
			loop;



	do-while:(最少执行次数为1次)
		do
		{
			loop;	
		}while(exp);

	for:(最少执行的次数为0次)
		for(exp1;exp2;exp3)
			loop;
	
	if-goto:(慎用:goto实现的是无条件的跳转,且不能跨函数跳转(函数跳转前需要保存现场和函数跳转回来需要恢复现场,goto不具备这样的功能))

死循环:
	while(1);
	for(;;);
	
杀掉死循环: ctrl+c


辅助控制关键字: break continue
	
							五. 数组
									构造类型之一,连续存放
一维数组
	1. 定义
			存储类型 数据类型 标识符[下标] 
				存储类型:是可以省略的
				下标: 必须是整型或者整型的常量表达式. 其实在C99的标准中数组下标可以是变量,但是需要编译器的支持.
	2. 初始化
			不初始化: 数组的内容是随机值
			部分初始化: 没有初始化的部分,auto设置为0
			全部初始化
			static
	3. 元素引用
			数组名[下标]
	4. 数组名
			数组名是表示地址的常量(不可以出现在等号(=)的左边), 也是数组的起始位置
			自己的理解:数组名就是它当前维度第一个元素的地址. 
				如果数组是一维数组, 那么它的维度就是第一个数组元素
				如果数组是二维数组, 那么它的维度就是第一行数组的地址,即第一行的行指针地址

	5. 数组越界

二维数组
	1. 定义,初始化
		[存储类型] 数组类型 标识符 [行下标][列下标] 
	2. 元素引用
		数组名 [行标][列标]
	3. 存储形式
		顺序存储, 按行存储
	4. 深入理解二维数组

字符数组
	1. 定义,初始化,存储特点
		[存储类型] 数据类型 标识符[下标]...
		单个字符初始化
		用字符串常量初始化
	2. 输入输出
	3. 常用函数

note: 
对于一维数组 int a[10];, a, &a, &a[0]
&a[0]==a==&a	
&a[0]代表数组首元素的地址
a是数组名,它就是数组首元素地址
&a是数组的首地址,在数值上与数组首元素的地址重合在一点,所以&a和数组首元素地址相等,但在语义上&a是数组的首地址

&a[0]+1 == a+1 	这两个变量都代表从数组的首地址开始偏移1个元素的长度
&a+1	这个变量的含义是从数组首地址开始偏移1整个数组的长度. (&的优先级高于+的优先级)

判断+1的长度到底是1个元素还是1整个数组的标准是:
看&到底取得是数组元素&a[x],还是取整个数组&a.

									六 指针

1 变量与指针
2 指针与指针变量
3 直接访问与间接访问
4 空指针与野指针
5 空类型
6 定义与初始化的书写规则
7 指针运算
	& * ++ -- 关系运算(例如: 指针之间比较大小,就是看指针地址的高低, 应用场景:两个指针都指向同一个数组,指针的大小可以判断出一些东西)
8 指针与数组
	指针与一维数组
		// TYPE NAME = VALUE;
		int a[3] = {1,2,3}
		int *p = a;
		a[i]: a[i] = *(a+i) = *(p+i) = p[i]
		&a[i]: &a[i] = a+i = p+i = &p[i]
		看上去一维数组名a和指针变量p可以混用,事实也是如此. 但是 p+i = &p[i] 看上去反直觉,可以想象前一个p是指针,后一个p是数组名
		但是他们俩是有本质区别的, 数组名a是一个常量, 而p是一个变量
			a++	//编译错误, 常量不能改变
			p++	//正常编译

			p++ 和 p+1 相同吗?
				两者不同, p++ 等价于 p=p+1, 指针变量p的值发生变化移动一个元素
						 p+1 表示下一个元素的地址,但是指针变量p的值并没有变化
		-------------------------------------------分割线------------------------------------------------------
			求数组的长度: sizeof(a) / sizeof(a[0]) 
			它也可以写成: sizeof(a) / sizeof(*a)
			因为 a[0] = *(a+0) = *a
		-------------------------------------------分割线------------------------------------------------------
			int *p = (int[3]){1,2,3};		//这个写法是不是有点别扭, 指针变量p指向一个匿名的数组
			int i;
			for(i=0; i<3; i++)
				printf("%p->%d\n", &p[i], p[i]);
	指针与二维数组
		int a[2][3] = {1,2,3,4,5,6};
		int i,j;
		for(i=0; i<2; i++){
			for(j=0; j<3; j++){
				//printf("%p->%d\n", &a[i][j], a[i][j]);
            	printf("%p->%d\n", *(a+i)+j, *(*(a+i)+j));
			}
		}
		&a[i][j]: &a[i][j] = *(a+i)+j
		a[i][j]: a[i][j] = *(*(a+i)+j)
			对于二维数组a来说, a是数组名,也是行指针, *(a+i)行指针取星操作后就降级得到了列指针, 拿到列指针之后再移动j个元素,
			*(*(a+i)+j)然后再取星操作就得到了具体的元素, 也就是a[i][j]


		int a[2][3] = {1,2,3,4,5,6};
		int *p;
		p = a;	//编译会产生Warning
		//warning: initialization of ‘int *’ from incompatible pointer type ‘int (*)[3]’ [-Wincompatible-pointer-types]
		这里产生警告的原因是类型不匹配, 首先a是一个地址, 这个地址可以存放在p中(所以编译器没报error而是warning), 但是p和a的意义不一样
		p是一个int类型的指针,一个列指针
		a是一个int[3]类型的行指针
		p+1是取下一个整型元素的地址
		a+1是跳过一行(3个整型),下一行的地址
		也就是说这样赋值的p,你没有办法通过p来定位列指针,因为p+1跳的是一行
		正确的写法应该是:  p = &a[0][0] 或者 *a, 或者 *(a+0)
		int a[2][3] = {1,2,3,4,5,6};
		int *p;
		p = &a[0][0];
		//p = *(a+0);		//行指针取星*操作后降级为列指针
		//p = *a;			//*a=*(a+0)

		通过指针p来遍历数组
		int a[2][3] = {1,2,3,4,5,6};
		int i, j;
		int *p = &a[0][0];
		for(i=0; i<6; i++)
			printf("%d ", p[i]);
		printf("\n");
		p = *a;
		for(i=0; i<6; i++)
		{
			printf("%d ", *p);
			p++;
		}
		

	note: 大多数情况下一级指针可以和一维数组名互换使用, 即一级指针等同于一位数组名.
	但是不能认为二级指针就等同于二位数组名,他们两个完全没有关系,是两个不同的东西,不能混用.
	如果想用指针来访问二维数组(或者多维数组),可以使用数组指针.

		
	指针与字符数组	
9 const与指针
	const的作用是把某些内容常量化(并不绝对,间接使用指针还是可以修改内容). 
	通常我们可以使用#define宏来定义一个常量,宏定义的缺点是它只是进行替换而不做类型检查.
	const修饰的单个变量必须在定义的时候就初始化.
		例如: const float pi = 3.14;
	指针常量: 指针指向不能发生变化(即,指针当前的地址不能改变),但是指针指向的内容可以改变
	常量指针: 指针指向的内容不能改变,但是指针的指向可以发生改变
	指针常量又是常量指针: 指针的指向和指针指向的内容都不可以修改.

	区分常量指针和指针常量的关键就在于*(星号)的位置,我们以星号为分界线,
		如果const在星号的左边,则为常量指针.如果const在星号的右边则为指针常量.
		如果我们将星号读作'指针',将const读作'常量'的话,内容正好符合.

	另外一种方式就是根据const修饰的内容来判断是指针常量还是常量指针.
		如果是 const *p, const修饰的是*p, 我们可以将*p理解为取出指针p指向的值(value), const 一个值(value),表示这个值不能改变,即常量指针
		如果是 * const p, 这里的const修饰的是变量p, 所以变量p被常量化,而不是p指向的值被常量化, 所以它是指针常量
			
		const int a;
		int const a;
			这两个都是定义一个常量,将普通变量常量化,没区别

		const int *p;
		int const *p;
			这两个都是常量指针,作用一模一样,没区别.

		int *const p;
			这是指针常量,

		const int *const p;
			这可以看成是const * const p, 
			这既是指针常量又是常量指针: 指针的指向和指针指向的内容都不可以修改.
			
		
10 指针数组和数组指针
	数组指针:指向数组的指针
		定义格式:	【存储类型】 数据类型 (*指针名)[下标] = 值
					下标的具体大小取决于所指向的数组更低维度的大小
				如: int (*p)[3];  -> type name; -> int[3] *p; 就是一个int[3]类型的指针p,所以p+1就是移动int[3]的大小
				int a[2][3] = {1,2,3,4,5,6};
				int (*p)[3] = a;	//这里的下标[3], 是由数组a[2][3]决定的
	指针数组:数组中的每个元素都是一个指针
		定义格式:	【存储类型】 数据类型 * 数组名[下标] 
		如: int * arr[3] -> type name; -> int *[3] arr;
	note: 仔细观察指针数组和数组指针的定义格式, 它们的区别就在于是否使用()将*和变量名限制在一起. 在一起的是数组指针,否则就是指针数组
11 多级指针	


									七 函数
1 函数的定义
	数据类型 函数名([数据类型 形参名, 数据类型 形参名...])

2 函数的传参
	值传递
	地址传递
	全局变量

3 函数的调用
	嵌套调用
	递归
4 函数与数组
	数组传参的时候回退化为指针
5 函数与指针
	指针函数: 函数的返回值是一个指针
		返回值 * 函数名(形参类型)
		如: int * func(int);
	函数指针: 指向函数的指针
		类型 (*指针名) (形参类型)
		如: int (*p) (int); //p是一个指向函数的指针,这个函数的返回值是int,有一个int类型的形参
	函数指针数组: 一个数组,数组的每个元素都是一个函数指针
		类型 (*数组名[下标])(形参类型)
		如: int (*arr[N])(int, char); 
		//arr是一个长度为N的数组,数组中的每个元素都是一个函数指针,指向一个返回值为int, 参数列表是int,char的函数
	
	指向指针函数的函数指针数组:
		如: int * (*funcp [N]) (int) 
		funcp是一个函数指针数组, 数组的每一个元素是一个指向指针函数{这个指针函数的原型是int * 函数名(int)}的函数指针

								八 构造类型
结构体

1 产生及意义
	数组只能存储相同类型,有局限. 使用结构体就可以把不同类型的数据存储到数组中
2 类型描述
	struct 结构体名
	{
		数据类型 成员1;
		数据类型 成员2;
		...
	};

	Note: 结构体定义时,最后面的分号是不能省略的. 
	不要把结构体定义在任何方法内部
	另外,结构体在定义的时候是不占用任何存储空间的,即,不能再定义结构体的时候初始化成员.没有空间来存放初始化的成员
	struct 结构体名
	{
		数据类型 成员1 = xxxxx;		//错误,不能在定义的时候初始化成员
		数据类型 成员2;
		...
	};

	除此以外还有匿名结构体
3 嵌套定义
	定义一个学生struct,学生的生日是另外一个结构体.
	以下两种方法等价
	第一种写法:
		struct birthday_st
		{
			int year;
			int month;
			int year;
		};

		struct student_st{
			int id;
			char name[32];
			struct birthday_st birth;
			int math;
			int chinese
		};
	------------------------------------------------
	第二种写法(嵌套定义):
		struct student_st
		{
			int id;
			char name[32];
			struct birthday_st
			{
				int year;
				int month;
				int day;
			} birth;	
			int math;
			int chinese;
		};
		
	Note: 可以使用__attribute__((packed))来告诉编译器不用将结构体内部的成员,字节对齐
	struct simple_st
	{
		int i
		char ch;
		float f;
		//char ch1;
	}__attribute__((packed));
4 定义变量(变量,数组,指针), 初始化及成员引用
	成员引用: 
		结构体变量名.成员名
		指针->成员名
		(*指针).成员名

	初始化结构体
	例如: 
	struct student_st stu = {10011, "Alan", {2011,11,11}, 98, 97};

	结构体还可以部分初始化
	例如:
	struct student_st stu = {.math=98, .chinese=97}; //只初始化了math和chinese两个成员
5 结构体占用内存空间的大小

6 函数传参(值,地址)



共用体
1 产生及意义
2 类型描述
	union 共同体名
	{
		数据类型 成员名1;
		数据类型 成员名2;
		......
	};
3 嵌套定义
	结构体嵌套共用体,或者共用体嵌套结构体
4 定义变量(变量,数组,指针),初始化及成员引用
	成员引用: 	变量名.成员名
				指针名->成员名
5 占用内存大小
6 函数传参(值,地址)
7 位域



枚举
enum 标识符
{
	成员1, 	
	成员2,
	...	
};

成员也可以直接赋值, 成员赋值后,它后面的成员自动赋值(+1)
enum 标识符
{
	成员1 = 1, 	
	成员2,
	...	
};

Note: 枚举的成员的值是可以重复的
enum day
{
	MON = 1;
	TUE,		// TUE = 2
	WED,		// WED = 3
	THU,		// THU = 4
	FRI = 1;
	SAT,		// SAT = 2	//这里因为FRI指定了值,所以根据新的值(1)再累加,得到2 
	SUN
};

enum的定义也可以是没有标识符的, 这时的enum就类似与一个或一组定义的宏(#define xxx x)
它与宏的却别是: 在预编译(gcc -E )的时候宏名会被替换为宏的值,而enum则不会, 这样在某些情况下能后更好的排查代码,
相对于被替换为值的宏,有的时候值所对应的逻辑含义更能够帮助我们排查代码
例如:
enum
{
	STATE_RUNNING = 1,
	STATE_CANCELED,
	STATE_OVER
};

struct job_st
{
	int id;
	int state;
	time_t start,end;
};
 
使用的时候可以直接使用enum的成员
int main()
{
	struct job_st job;
	/* 
	获取job的state 
	*/
	switch(job.state){
		case STATE_RUNNING:
			// do something
			break;
		case State_canceled:
			// do something
			break;
		case state_over:
			// do something
			break;
		default:
			// do something
			
	};
	return 0;
}

								九 动态内存管理	
malloc ralloc realloc free

原则: 谁申请谁释放

typedef: 为已有的数据类型改名

语法:
typedef 已有的数据类型 新名字;

/*  普通类型 
typedef int ARR[6];		//这里不是把int重命名为ARR[6], 而是把int[6]重命名为ARR  int[6] --> ARR
ARR a; 	--> int a[6];	
//Tips: 如果看不清楚ARR a代表什么,就把变量等价替换到重命名类型的定义中去,然后抹掉typedef
ARR a; ==> typedef int a[6]; ==> int a[6];
*/

/* 结构体 
struct node_st
{
	int i;
	float f;
};

typedef struct node_st NODE;
NODE a; --> struct node_st a;

typedef struct node_st *NODEP;
NODEP p; --> struct node_st *p;

上面的写法等价于下面这种写法
typedef struct  	//这个结构体可以是匿名的 
{
	int i;
	float f;
} NODE, *NODEP;

NODE a;  //一个结构体变量
NODEP p; //一个结构体指针

注意: 不推荐下面这个写法,因为它把指针的符号(*)抹在定义里面了. 
NODEP p; 表示p是一个struct 指针, 表现的并不直观
而使用上面重定义struct的写法, Node *p 能够很清晰的表明这是一个指针 
*/

/* 函数类型
typedef int FUNC(int); --> int(int) FUNC;
FUNC f; --> int f(int);
*/

/* 指针函数 
typedef int *FUNCP(int);  
FUNCP p; --> int *p(int);
*/

/* 函数指针
typedef int *(*FUNCP)(int);
FUNCP p; --> int *(*p)(int); //p是一个指向函数的指针,这个函数是一个指针函数,它接收int为参数,返回int *
*/



								静态库和动态库

静态库

libxx.a
xx 指代库名

ar -cr libxx.a yyy.o

发布到
/usr/local/include				//头文件
/usr/local/lib					//库文件

gcc -L/usr/local/lib -o main main.o -lxx
-l 参数必须在最后, 有依赖


动态库

libxx.so

gcc -shared -fpic -o libxx.so yyy.c

发布到
/usr/local/include
/usr/local/lib

在 /etc/ld.so.conf 中添加路径 /usr/local/lib
/sbin/ldconfig		重读 	/etc/ld.so.conf

gcc -I/usr/local/include -L/usr/local/lib -o ... -lxx

-I/usr/local/include 和 -L/usr/local/lib是默认设定
-lxx 表示依赖的库,如果依赖多个库文件,库文件之间又有依赖,那么需要把被依赖的库文件写在后面
例如: 编译main.c需要依赖xx1和xx2两个库文件,并且xx1库本身依赖xx2库
gcc -o main main.c -lstack -lllist			//stack库文件依赖llist库,所以llist必须写在stack的后面

ldd - printf shared library dependencies


非root用户发布
cp xx.so ~/lib
export LD_LIBRARY_PATH=~/lib


								树
深度(层数)
度(根节点所包含的子树的个数)
叶子(再也没有子节点的节点)
孩子(相对于父节点,)
兄弟(都有同一个父节点)
堂兄弟(他们的父节点是兄弟)


二叉树:当前树的所有节点, 最多只能有两个孩子,并且所有孩子都能区分为左孩子还是右孩子
二叉树有一个特点就是可以很方便的使用顺序的模型来存储二叉树,但是有可能会很浪费空间

满二叉树:如果一颗深度为k(k>=1)的树,有2的k次方-1个节点,那么它就是一颗满二叉树 

完全二叉树: 一棵(二叉)树除了最后2层可以有不满足2个孩子节点的节点之外(节点可以没有孩子节点,或者只有1个孩子节点,但是这个孩子节点必须是左孩子),
其他所有的节点都必须有2个节点


存储: 顺序, 链式

顺序:可以很直观的存储二叉树(存不了其他树),但是有可能会很浪费空间. 所以顺序模型不是很适合存储树 

		n
	   / \
	  /   \
	 2n   2n+1

链式:
	struct {
		*左孩子;
		data;
		*右孩子
	}

遍历: 按行, 先序, 中序, 后序
		

二叉树
1,2,3,7,6,5,9,8,4

广义表
cefadjbh

搜索树
ant:a small insect that lives in group
butterfly:a flying insect with a long thin body
cobra:a highly dangerous snake
donkey:a animal with short legs and long ears


								俄罗斯方块(单机版,对战版,移植到开发板)
1 图形(ANSI_VT, framebuffer) 
	老师推荐使用framebuffer, ANSI_VT是以终端的光标为单位画图, framebuffer是以像素为单位画图的,
	framebuffer的程序以后可以移植到开发板,ASNSI_VT则不行. 不过使用framebuffer需要搭建一些环境
2 输入设备的设置
3 并发(方块是一直不停的往底部下落,按下方向键或者变形键不会停止方块下落的动作)